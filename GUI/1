// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum GUI_ComponentType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case vstack = 0
  case hstack = 1
  case text = 2
  case button = 3
  case image = 4
  case spacer = 5
  case divider = 6

  public static var max: GUI_ComponentType { return .divider }
  public static var min: GUI_ComponentType { return .vstack }
}


public struct GUI_Component: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case content = 6
    case label = 8
    case children = 10
    case font = 12
    case fontSize = 14
    case foregroundColor = 16
    case isHidden = 18
    case action = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: GUI_ComponentType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .vstack : GUI_ComponentType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .vstack }
  public var content: String? { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var contentSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.content.v) }
  public var label: String? { let o = _accessor.offset(VTOFFSET.label.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var labelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.label.v) }
  public var hasChildren: Bool { let o = _accessor.offset(VTOFFSET.children.v); return o == 0 ? false : true }
  public var childrenCount: Int32 { let o = _accessor.offset(VTOFFSET.children.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func children(at index: Int32) -> GUI_Component? { let o = _accessor.offset(VTOFFSET.children.v); return o == 0 ? nil : GUI_Component(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var font: String? { let o = _accessor.offset(VTOFFSET.font.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var fontSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.font.v) }
  public var fontSize: Float32 { let o = _accessor.offset(VTOFFSET.fontSize.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var foregroundColor: String? { let o = _accessor.offset(VTOFFSET.foregroundColor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var foregroundColorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.foregroundColor.v) }
  public var isHidden: Bool { let o = _accessor.offset(VTOFFSET.isHidden.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var action: String? { let o = _accessor.offset(VTOFFSET.action.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var actionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.action.v) }
  public static func startComponent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(type: GUI_ComponentType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func add(content: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: content, at: VTOFFSET.content.p) }
  public static func add(label: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: label, at: VTOFFSET.label.p) }
  public static func addVectorOf(children: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: children, at: VTOFFSET.children.p) }
  public static func add(font: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: font, at: VTOFFSET.font.p) }
  public static func add(fontSize: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fontSize, def: 0.0, at: VTOFFSET.fontSize.p) }
  public static func add(foregroundColor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: foregroundColor, at: VTOFFSET.foregroundColor.p) }
  public static func add(isHidden: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isHidden, def: false,
   at: VTOFFSET.isHidden.p) }
  public static func add(action: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: action, at: VTOFFSET.action.p) }
  public static func endComponent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createComponent(
    _ fbb: inout FlatBufferBuilder,
    type: GUI_ComponentType = .vstack,
    contentOffset content: Offset = Offset(),
    labelOffset label: Offset = Offset(),
    childrenVectorOffset children: Offset = Offset(),
    fontOffset font: Offset = Offset(),
    fontSize: Float32 = 0.0,
    foregroundColorOffset foregroundColor: Offset = Offset(),
    isHidden: Bool = false,
    actionOffset action: Offset = Offset()
  ) -> Offset {
    let __start = GUI_Component.startComponent(&fbb)
    GUI_Component.add(type: type, &fbb)
    GUI_Component.add(content: content, &fbb)
    GUI_Component.add(label: label, &fbb)
    GUI_Component.addVectorOf(children: children, &fbb)
    GUI_Component.add(font: font, &fbb)
    GUI_Component.add(fontSize: fontSize, &fbb)
    GUI_Component.add(foregroundColor: foregroundColor, &fbb)
    GUI_Component.add(isHidden: isHidden, &fbb)
    GUI_Component.add(action: action, &fbb)
    return GUI_Component.endComponent(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: GUI_ComponentType.self)
    try _v.visit(field: VTOFFSET.content.p, fieldName: "content", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.label.p, fieldName: "label", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.children.p, fieldName: "children", required: false, type: ForwardOffset<Vector<ForwardOffset<GUI_Component>, GUI_Component>>.self)
    try _v.visit(field: VTOFFSET.font.p, fieldName: "font", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.fontSize.p, fieldName: "fontSize", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.foregroundColor.p, fieldName: "foregroundColor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.isHidden.p, fieldName: "isHidden", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.action.p, fieldName: "action", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct GUI_Screen: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case url = 6
    case state = 8
    case components = 10
    case backgroundColor = 12
    case isTransparent = 14
    case blurEffect = 16
    case backgroundImage = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var state: String? { let o = _accessor.offset(VTOFFSET.state.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.state.v) }
  public var hasComponents: Bool { let o = _accessor.offset(VTOFFSET.components.v); return o == 0 ? false : true }
  public var componentsCount: Int32 { let o = _accessor.offset(VTOFFSET.components.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func components(at index: Int32) -> GUI_Component? { let o = _accessor.offset(VTOFFSET.components.v); return o == 0 ? nil : GUI_Component(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var backgroundColor: String? { let o = _accessor.offset(VTOFFSET.backgroundColor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var backgroundColorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.backgroundColor.v) }
  public var isTransparent: Bool { let o = _accessor.offset(VTOFFSET.isTransparent.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var blurEffect: String? { let o = _accessor.offset(VTOFFSET.blurEffect.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var blurEffectSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.blurEffect.v) }
  public var backgroundImage: String? { let o = _accessor.offset(VTOFFSET.backgroundImage.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var backgroundImageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.backgroundImage.v) }
  public static func startScreen(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(state: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: state, at: VTOFFSET.state.p) }
  public static func addVectorOf(components: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: components, at: VTOFFSET.components.p) }
  public static func add(backgroundColor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: backgroundColor, at: VTOFFSET.backgroundColor.p) }
  public static func add(isTransparent: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isTransparent, def: false,
   at: VTOFFSET.isTransparent.p) }
  public static func add(blurEffect: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: blurEffect, at: VTOFFSET.blurEffect.p) }
  public static func add(backgroundImage: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: backgroundImage, at: VTOFFSET.backgroundImage.p) }
  public static func endScreen(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createScreen(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    urlOffset url: Offset = Offset(),
    stateOffset state: Offset = Offset(),
    componentsVectorOffset components: Offset = Offset(),
    backgroundColorOffset backgroundColor: Offset = Offset(),
    isTransparent: Bool = false,
    blurEffectOffset blurEffect: Offset = Offset(),
    backgroundImageOffset backgroundImage: Offset = Offset()
  ) -> Offset {
    let __start = GUI_Screen.startScreen(&fbb)
    GUI_Screen.add(name: name, &fbb)
    GUI_Screen.add(url: url, &fbb)
    GUI_Screen.add(state: state, &fbb)
    GUI_Screen.addVectorOf(components: components, &fbb)
    GUI_Screen.add(backgroundColor: backgroundColor, &fbb)
    GUI_Screen.add(isTransparent: isTransparent, &fbb)
    GUI_Screen.add(blurEffect: blurEffect, &fbb)
    GUI_Screen.add(backgroundImage: backgroundImage, &fbb)
    return GUI_Screen.endScreen(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.state.p, fieldName: "state", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.components.p, fieldName: "components", required: false, type: ForwardOffset<Vector<ForwardOffset<GUI_Component>, GUI_Component>>.self)
    try _v.visit(field: VTOFFSET.backgroundColor.p, fieldName: "backgroundColor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.isTransparent.p, fieldName: "isTransparent", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.blurEffect.p, fieldName: "blurEffect", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.backgroundImage.p, fieldName: "backgroundImage", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct GUI_UI: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case screens = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasScreens: Bool { let o = _accessor.offset(VTOFFSET.screens.v); return o == 0 ? false : true }
  public var screensCount: Int32 { let o = _accessor.offset(VTOFFSET.screens.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func screens(at index: Int32) -> GUI_Screen? { let o = _accessor.offset(VTOFFSET.screens.v); return o == 0 ? nil : GUI_Screen(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startUI(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(screens: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: screens, at: VTOFFSET.screens.p) }
  public static func endUI(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUI(
    _ fbb: inout FlatBufferBuilder,
    screensVectorOffset screens: Offset = Offset()
  ) -> Offset {
    let __start = GUI_UI.startUI(&fbb)
    GUI_UI.addVectorOf(screens: screens, &fbb)
    return GUI_UI.endUI(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.screens.p, fieldName: "screens", required: false, type: ForwardOffset<Vector<ForwardOffset<GUI_Screen>, GUI_Screen>>.self)
    _v.finish()
  }
}

